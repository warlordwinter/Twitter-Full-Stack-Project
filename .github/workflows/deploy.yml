name: Deploy Lambda Functions

on:
  push:
    branches:
      - main
      - Milestone3A
      - Milestone4A
  workflow_dispatch:

env:
  AWS_REGION: us-west-2
  S3_BUCKET: wiley-tweeter-storage

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "20"

      - name: Install dependencies
        run: |
          cd tweeter-web-starter/tweeter-shared && npm install
          cd ../tweeter-server && npm install

      - name: Build shared package
        run: |
          cd tweeter-web-starter/tweeter-shared
          npm run build

          # Debug - show build output
          echo "Shared package build output:"
          ls -R dist/

      - name: Build server package
        run: |
          cd tweeter-web-starter/tweeter-server
          npm run build

          # Debug - show build output
          echo "Server build output:"
          ls -R dist/

      - name: Prepare Lambda Layer
        run: |
          # Create a fresh nodejs directory
          rm -rf nodejs
          mkdir -p nodejs

          # Copy node_modules from tweeter-server
          cp -r tweeter-web-starter/tweeter-server/node_modules nodejs/

          # Remove any existing tweeter-shared from node_modules and copy the new one
          rm -rf nodejs/node_modules/tweeter-shared
          cp -r tweeter-web-starter/tweeter-shared nodejs/node_modules/

          # Debug - show directory structure before zipping
          echo "Directory structure before zipping:"
          ls -R nodejs

          # Create the layer zip
          zip -r nodejs.zip nodejs

          # Debug - show contents
          echo "Contents of nodejs.zip:"
          unzip -l nodejs.zip

      - name: Package Lambda Functions
        run: |
          # Generate timestamp for unique zip names
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          LAMBDA_ZIP="lambdas-${TIMESTAMP}.zip"

          # Show what we're about to zip
          echo "Contents of tweeter-server/dist directory:"
          ls -R tweeter-web-starter/tweeter-server/dist

          # Create zip with contents of dist (without including dist directory)
          cd tweeter-web-starter/tweeter-server/dist
          zip -r ../../../$LAMBDA_ZIP *
          cd ../../../

          # Show what was zipped
          echo "Contents of $LAMBDA_ZIP:"
          unzip -l $LAMBDA_ZIP

          # Check if bucket exists and create if needed
          if ! aws s3api head-bucket --bucket ${{ env.S3_BUCKET }} 2>/dev/null; then
            aws s3api create-bucket --bucket ${{ env.S3_BUCKET }} --region ${{ env.AWS_REGION }} --create-bucket-configuration LocationConstraint=${{ env.AWS_REGION }}
            aws s3api put-bucket-versioning --bucket ${{ env.S3_BUCKET }} --versioning-configuration Status=Enabled
          fi

          # Upload files and capture version IDs
          LAMBDA_VERSION=$(aws s3api put-object --bucket ${{ env.S3_BUCKET }} --key lambdas.zip --body $LAMBDA_ZIP --query 'VersionId' --output text)
          LAYER_VERSION=$(aws s3api put-object --bucket ${{ env.S3_BUCKET }} --key nodejs.zip --body nodejs.zip --query 'VersionId' --output text)

          # Store the versions for CloudFormation
          echo "DEPLOY_TIMESTAMP=${TIMESTAMP}" >> $GITHUB_ENV
          echo "LAMBDA_VERSION=${LAMBDA_VERSION}" >> $GITHUB_ENV
          echo "LAYER_VERSION=${LAYER_VERSION}" >> $GITHUB_ENV

      - name: Deploy CloudFormation stack
        run: |
          # Use the versions for both Layer and Lambda
          echo "Using timestamp: $DEPLOY_TIMESTAMP"
          echo "Lambda version: $LAMBDA_VERSION"
          echo "Layer version: $LAYER_VERSION"

          # Upload CloudFormation template to S3
          aws s3 cp tweeter-web-starter/tweeter-server/cloudformation.yml s3://${{ env.S3_BUCKET }}/cloudformation.yml

          # Check if stack exists
          if aws cloudformation describe-stacks --stack-name tweeter-api 2>/dev/null; then
            echo "Stack exists, updating..."
            aws cloudformation update-stack \
              --stack-name tweeter-api \
              --template-url https://${{ env.S3_BUCKET }}.s3.${{ env.AWS_REGION }}.amazonaws.com/cloudformation.yml \
              --capabilities CAPABILITY_IAM \
              --parameters \
                ParameterKey=S3Bucket,ParameterValue=${{ env.S3_BUCKET }} \
                ParameterKey=NodejsLayerKey,ParameterValue=nodejs.zip \
                ParameterKey=LambdasKey,ParameterValue=lambdas.zip \
                ParameterKey=Timestamp,ParameterValue=$DEPLOY_TIMESTAMP

            # Wait for stack update to complete
            aws cloudformation wait stack-update-complete --stack-name tweeter-api
          else
            echo "Stack does not exist, creating..."
            aws cloudformation create-stack \
              --stack-name tweeter-api \
              --template-url https://${{ env.S3_BUCKET }}.s3.${{ env.AWS_REGION }}.amazonaws.com/cloudformation.yml \
              --capabilities CAPABILITY_IAM \
              --parameters \
                ParameterKey=S3Bucket,ParameterValue=${{ env.S3_BUCKET }} \
                ParameterKey=NodejsLayerKey,ParameterValue=nodejs.zip \
                ParameterKey=LambdasKey,ParameterValue=lambdas.zip \
                ParameterKey=Timestamp,ParameterValue=$DEPLOY_TIMESTAMP

            # Wait for stack creation to complete
            aws cloudformation wait stack-create-complete --stack-name tweeter-api
          fi
      - name: Deploy API Gateway stage
        run: |
          # Extract REST_API_ID dynamically
          REST_API_ID=$(aws apigateway get-rest-apis --query "items[0].id" --output text)

          # Extract STAGE_NAME dynamically (if you have multiple stages, adjust query accordingly)
          STAGE_NAME=prod

          # Extract DEPLOYMENT_ID dynamically (get the most recent deployment for the stage)
          DEPLOYMENT_ID=$(aws apigateway get-deployments --rest-api-id $REST_API_ID --query "items[0].id" --output text)

          # Debug output to verify variables
          echo "REST_API_ID: $REST_API_ID"
          echo "STAGE_NAME: $STAGE_NAME"
          echo "DEPLOYMENT_ID: $DEPLOYMENT_ID"

          # Update API Gateway stage with the extracted deployment ID
          echo "Updating stage '$STAGE_NAME' for API $REST_API_ID to deployment $DEPLOYMENT_ID..."

          if ! aws apigateway update-stage \
            --rest-api-id $REST_API_ID \
            --stage-name $STAGE_NAME \
            --patch-operations op=replace,path=/deploymentId,value=$DEPLOYMENT_ID; then
            echo "API Gateway stage update failed!" >&2
            exit 1
          fi
